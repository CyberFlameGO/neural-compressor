:orphan:

:py:mod:`neural_compressor.strategy.bayesian`
=============================================

.. py:module:: neural_compressor.strategy.bayesian


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   neural_compressor.strategy.bayesian.BayesianTuneStrategy
   neural_compressor.strategy.bayesian.TargetSpace



Functions
~~~~~~~~~

.. autoapisummary::

   neural_compressor.strategy.bayesian.acq_max



.. py:class:: BayesianTuneStrategy(model, conf, q_dataloader, q_func=None, eval_dataloader=None, eval_func=None, dicts=None, q_hooks=None)

   Bases: :py:obj:`neural_compressor.strategy.strategy.TuneStrategy`

   The tuning strategy using bayesian search in tuning space.

   :param model: The FP32 model specified for low precision tuning.
   :type model: object
   :param conf: The Conf class instance initialized from user yaml
                config file.
   :type conf: Conf
   :param q_dataloader: Data loader for calibration, mandatory for
                        post-training quantization.
                        It is iterable and should yield a tuple (input,
                        label) for calibration dataset containing label,
                        or yield (input, _) for label-free calibration
                        dataset. The input could be a object, list, tuple or
                        dict, depending on user implementation, as well as
                        it can be taken as model input.
   :type q_dataloader: generator
   :param q_func: Reserved for future use.
   :type q_func: function, optional
   :param eval_dataloader: Data loader for evaluation. It is iterable
                           and should yield a tuple of (input, label).
                           The input could be a object, list, tuple or dict,
                           depending on user implementation, as well as it can
                           be taken as model input. The label should be able
                           to take as input of supported metrics. If this
                           parameter is not None, user needs to specify
                           pre-defined evaluation metrics through configuration
                           file and should set "eval_func" parameter as None.
                           Tuner will combine model, eval_dataloader and
                           pre-defined metrics to run evaluation process.
   :type eval_dataloader: generator, optional
   :param eval_func: The evaluation function provided by user.
                     This function takes model as parameter, and
                     evaluation dataset and metrics should be
                     encapsulated in this function implementation and
                     outputs a higher-is-better accuracy scalar value.

                     The pseudo code should be something like:

                     def eval_func(model):
                          input, label = dataloader()
                          output = model(input)
                          accuracy = metric(output, label)
                          return accuracy
   :type eval_func: function, optional
   :param dicts: The dict containing resume information.
                 Defaults to None.
   :type dicts: dict, optional

   .. py:method:: next_tune_cfg()

      The generator of yielding next tuning config to traverse by concrete strategies
      according to last tuning result.




.. py:function:: acq_max(ac, gp, y_max, bounds, random_seed, n_warmup=10000, n_iter=10)

   A function to find the maximum of the acquisition function
   :param ac:
   :type ac: The acquisition function object that return its point-wise value.
   :param gp:
   :type gp: A gaussian process fitted to the relevant data.
   :param y_max:
   :type y_max: The current maximum known value of the target function.
   :param bounds:
   :type bounds: The variables bounds to limit the search of the acq max.
   :param random_state:
   :type random_state: instance of np.RandomState random number generator
   :param n_warmup:
   :type n_warmup: number of times to randomly sample the acquisition function
   :param n_iter:
   :type n_iter: number of times to run scipy.minimize

   :returns:
   :rtype: x_max, The arg max of the acquisition function.


.. py:class:: TargetSpace(pbounds, random_seed=9527)

   Bases: :py:obj:`object`

   Holds the param-space coordinates (X) and target values (Y)
   Allows for constant-time appends while ensuring no duplicates are added

   .. py:method:: register(params, target)

      Append a point and its target value to the known data.
      :param params: a single point, with len(params) == self.dim
      :type params: ndarray
      :param target: target function value
      :type target: float

      :raises KeyError:: if the point is not unique

      .. rubric:: Notes

      runs in amortized constant time


   .. py:method:: get_target(params)

      Get the target value of params
      ----------
      params: ndarray
          a single point, with len(params) == self.dim
      :returns: **target** -- target function value.
      :rtype: float


   .. py:method:: random_sample()

      Creates random points within the bounds of the space.
      :returns: **data** -- [num x dim] array points with dimensions corresponding to `self._keys`
      :rtype: ndarray


   .. py:method:: max()

      Get maximum target value found and corresponding parametes.


   .. py:method:: res()

      Get all target values found and corresponding parametes.



